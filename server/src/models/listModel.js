// server/src/models/listModel.js
// Supabase version - List model functions

const { db } = require('../utils/dbConnect');

/**
 * Create a new list
 * @param {Object} listData - List data
 * @returns {Object} Created list
 */
exports.createList = async (listData) => {
    try {
        // list_id is auto-generated by PostgreSQL trigger
        const { data, error } = await db
            .from('lists')
            .insert({
                company_id: listData.company_id,
                name: listData.name,
                description: listData.description || '',
                tag_logic: listData.tag_logic || 'any',
                profile_count: listData.profile_count || 0,
                status: listData.status || 'active',
                created_by: listData.created_by
            })
            .select()
            .single();

        if (error) throw error;

        // If tags provided, add them to list_tags junction table
        if (listData.tags && listData.tags.length > 0) {
            const tagInserts = listData.tags.map(tagId => ({
                list_id: data.id,
                tag_id: tagId
            }));

            await db.from('list_tags').insert(tagInserts);
        }

        // Return with tags populated
        return exports.getListById(data.id, listData.company_id);
    } catch (error) {
        throw error;
    }
};

/**
 * Get all lists for a company
 * @param {string} company_id - Company ID
 * @param {Object} options - Query options
 * @returns {Object} Lists and total count
 */
exports.getAllLists = async (company_id, options = {}) => {
    try {
        const { limit = 50, skip = 0, search = '', status = 'active' } = options;

        let query = db
            .from('lists')
            .select(`
                *,
                tags:list_tags(tag:tags(*))
            `, { count: 'exact' })
            .eq('company_id', company_id);

        if (status) {
            query = query.eq('status', status);
        }

        if (search) {
            query = query.ilike('name', `%${search}%`);
        }

        const { data: lists, error, count } = await query
            .order('created_at', { ascending: false })
            .range(skip, skip + limit - 1);

        if (error) throw error;

        // Transform tags from junction table format
        const transformedLists = (lists || []).map(list => ({
            ...list,
            _id: list.id,
            tags: (list.tags || [])
                .map(lt => lt.tag)
                .filter(t => t !== null)
                .map(t => ({ ...t, _id: t.id }))
        }));

        return {
            lists: transformedLists,
            total: count || 0
        };
    } catch (error) {
        throw error;
    }
};

/**
 * Get list by ID
 * @param {string} listId - List UUID
 * @param {string} company_id - Company ID
 * @returns {Object|null} List or null
 */
exports.getListById = async (listId, company_id) => {
    try {
        const { data, error } = await db
            .from('lists')
            .select(`
                *,
                tags:list_tags(tag:tags(*))
            `)
            .eq('id', listId)
            .eq('company_id', company_id)
            .single();

        if (error) {
            if (error.code === 'PGRST116') return null;
            throw error;
        }

        if (!data) return null;

        // Transform tags from junction table format
        return {
            ...data,
            _id: data.id,
            tags: (data.tags || [])
                .map(lt => lt.tag)
                .filter(t => t !== null)
                .map(t => ({ ...t, _id: t.id }))
        };
    } catch (error) {
        throw error;
    }
};

/**
 * Get list by list_id (6-char ID)
 * @param {string} list_id - 6-character list ID
 * @param {string} company_id - Company ID
 * @returns {Object|null} List or null
 */
exports.getListByListId = async (list_id, company_id) => {
    try {
        const { data, error } = await db
            .from('lists')
            .select(`
                *,
                tags:list_tags(tag:tags(*))
            `)
            .eq('list_id', list_id.toUpperCase())
            .eq('company_id', company_id)
            .single();

        if (error) {
            if (error.code === 'PGRST116') return null;
            throw error;
        }

        if (!data) return null;

        // Transform tags from junction table format
        return {
            ...data,
            _id: data.id,
            tags: (data.tags || [])
                .map(lt => lt.tag)
                .filter(t => t !== null)
                .map(t => ({ ...t, _id: t.id }))
        };
    } catch (error) {
        throw error;
    }
};

/**
 * Update list
 * @param {string} listId - List UUID
 * @param {string} company_id - Company ID
 * @param {Object} updateData - Data to update
 * @returns {Object|null} Updated list or null
 */
exports.updateList = async (listId, company_id, updateData) => {
    try {
        const { tags, ...otherData } = updateData;

        // Update the list record
        const { data, error } = await db
            .from('lists')
            .update({
                name: otherData.name,
                description: otherData.description,
                tag_logic: otherData.tag_logic,
                status: otherData.status
                // updated_at is set by trigger
            })
            .eq('id', listId)
            .eq('company_id', company_id)
            .select()
            .single();

        if (error) throw error;

        // If tags provided, replace them
        if (tags !== undefined) {
            // Delete existing tags
            await db.from('list_tags').delete().eq('list_id', listId);

            // Add new tags
            if (tags.length > 0) {
                const tagInserts = tags.map(tagId => ({
                    list_id: listId,
                    tag_id: tagId
                }));
                await db.from('list_tags').insert(tagInserts);
            }
        }

        // Return with tags populated
        return exports.getListById(listId, company_id);
    } catch (error) {
        throw error;
    }
};

/**
 * Delete list
 * @param {string} listId - List UUID
 * @param {string} company_id - Company ID
 * @returns {Object|null} Deleted list or null
 */
exports.deleteList = async (listId, company_id) => {
    try {
        // list_tags will be deleted automatically via CASCADE
        const { data, error } = await db
            .from('lists')
            .delete()
            .eq('id', listId)
            .eq('company_id', company_id)
            .select()
            .single();

        if (error) {
            if (error.code === 'PGRST116') return null;
            throw error;
        }

        return data ? { ...data, _id: data.id } : null;
    } catch (error) {
        throw error;
    }
};

/**
 * Add tags to list
 * @param {string} listId - List UUID
 * @param {string} company_id - Company ID
 * @param {Array} tagIds - Array of tag UUIDs
 * @returns {Object|null} Updated list or null
 */
exports.addTagsToList = async (listId, company_id, tagIds) => {
    try {
        // Verify list belongs to company
        const { data: list } = await db
            .from('lists')
            .select('id')
            .eq('id', listId)
            .eq('company_id', company_id)
            .single();

        if (!list) return null;

        // Insert tags (ignore duplicates)
        const tagInserts = tagIds.map(tagId => ({
            list_id: listId,
            tag_id: tagId
        }));

        await db
            .from('list_tags')
            .upsert(tagInserts, { onConflict: 'list_id,tag_id', ignoreDuplicates: true });

        // Return updated list
        return exports.getListById(listId, company_id);
    } catch (error) {
        throw error;
    }
};

/**
 * Remove tags from list
 * @param {string} listId - List UUID
 * @param {string} company_id - Company ID
 * @param {Array} tagIds - Array of tag UUIDs
 * @returns {Object|null} Updated list or null
 */
exports.removeTagsFromList = async (listId, company_id, tagIds) => {
    try {
        // Verify list belongs to company
        const { data: list } = await db
            .from('lists')
            .select('id')
            .eq('id', listId)
            .eq('company_id', company_id)
            .single();

        if (!list) return null;

        // Delete specified tags
        await db
            .from('list_tags')
            .delete()
            .eq('list_id', listId)
            .in('tag_id', tagIds);

        // Return updated list
        return exports.getListById(listId, company_id);
    } catch (error) {
        throw error;
    }
};

/**
 * Get profiles for a list (based on assigned tags)
 * @param {string} listId - List UUID
 * @param {string} company_id - Company ID
 * @param {Object} options - Query options
 * @returns {Object} Profiles and total count
 */
exports.getListProfiles = async (listId, company_id, options = {}) => {
    try {
        const { limit = 50, skip = 0 } = options;

        // Get the list with tags
        const list = await exports.getListById(listId, company_id);
        if (!list || !list.tags || list.tags.length === 0) {
            return { profiles: [], total: 0 };
        }

        const tagIds = list.tags.map(t => t._id || t.id);
        const profileTagModel = require('./profileTagModel');

        // Use the profileTagModel's getProfilesByTags function
        return await profileTagModel.getProfilesByTags(
            tagIds,
            company_id,
            list.tag_logic || 'any',
            { limit, skip }
        );
    } catch (error) {
        throw error;
    }
};

/**
 * Update profile count for a list
 * @param {string} listId - List UUID
 * @returns {Object|null} Updated list or null
 */
exports.updateListProfileCount = async (listId) => {
    try {
        // Get the list
        const { data: list, error: listError } = await db
            .from('lists')
            .select('company_id')
            .eq('id', listId)
            .single();

        if (listError || !list) return null;

        // Get profile count
        const { total } = await exports.getListProfiles(listId, list.company_id, { limit: 1 });

        // Update count
        const { data, error } = await db
            .from('lists')
            .update({ profile_count: total })
            .eq('id', listId)
            .select()
            .single();

        if (error) throw error;

        return data ? { ...data, _id: data.id } : null;
    } catch (error) {
        throw error;
    }
};
